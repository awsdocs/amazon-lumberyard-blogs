# Building a Smarter Foundation: Math Improvements in Lumberyard

<p><em>Authored by Karl Berg, Principal Engineer on Amazon Lumberyard</em></p> 
       <p>Nothing pushes the computational power of modern computers quite like real-time 3D games. From the vector algebra used to transform 3D scenes to 2D screen space, to the visibility queries used for rendering and AI, to the deformation of surfaces around bones for characters, to the integrators used to solve complex chains of physics constraints: game engines require a robust and extremely efficient mathematical foundation to build these complex systems.</p> 
       <p>Due to the historical origins of Lumberyard 1.x, what we had was a mix of legacy CryEngine math mixed together with a math library inherited from our Double Helix acquisition, along with some Lumberyard-specific additions sprinkled throughout. Over time, we realized our old math library had a lot of shortcomings, including: highly inconsistent API design that confused developers and led to unpredictable results; outdated concepts around compiler auto-vectorization; questionable and undocumented usage of estimate instructions; hardcoded intrinsics woven into class implementations that made updates for modern CPUs (like ARM variants) a real pain; and an archaic transform representation that required far too much effort to integrate into modern game feature implementations.</p> 
       <p>To support next generation Lumberyard development, we’ve addressed the above points with some impressive results in terms of improvements to performance and accuracy.</p> 
       <p>Here is a quick overview of some of the changes that have been made:</p> 
       <ul> 
        <li>Awkward methods have been deprecated and removed.</li> 
        <li><code>Exact</code> and <code>Approx</code> overloads of mathematical functions have been removed. Where an estimate instruction showed performance benefit, we’ve added Estimate operations instead. All functions not marked Estimate are full precision.</li> 
        <li><code>AZ::Transform</code> has been decomposed so it now contains individual <code>Translation</code>, <code>Orientation</code>, and <code>Scale fields</code>.</li> 
        <li>We have a brand new C-style SIMD layer, accessible through the <code>AZ::Simd</code> namespace which now supports ARM Neon in addition to SSE on x64.</li> 
        <li>We have a new set of fast performing SIMD trig functions with much improved accuracy, including: <code>sin</code>, <code>cos</code>, <code>sincos</code>, <code>acos</code>, <code>atan</code>, and <code>atan2</code> which work across CPU architectures due to the new <code>AZ::Simd</code> layer.</li> 
        <li>We’ve added an <code>AZ::Frustum</code> type and implemented a robust set of visibility operations required for our next generation networking, streaming, and rendering efforts.</li> 
        <li>Over 1,000 unit tests have been added or refactored to validate the correctness of the new math library.</li> 
        <li>We’ve added more than 450 microbenchmarks to validate and monitor performance.</li> 
       </ul> 
       <h2>API Cleanup</h2> 
       <p>The public interfaces for <code>Vector2</code>/<code>Vector3</code>/<code>Vector4</code> and <code>Matrix3x3</code>/<code>Matrix4x4</code> were often quite inconsistent, with functionality organically grafted into these classes over many years. This often led to to surprise when methods on one vector or matrix type either didn’t exist or behaved differently than the methods on a different vector or matrix type. We have performed a full audit of these classes, and have normalized the public interfaces to remove any surprises customers might have when mixing between vector or matrix types.</p> 
       <p>Awkward operators have been removed from these classes. This includes naked equality and product operators where the meaning of such operations were unclear. In our new implementation, callers should explicitly use the <code>IsClose</code> or <code>TransformVector</code>/<code>TransformPoint</code> methods to resolve any ambiguity in what the operations are actually doing.</p> 
       <p>Finally, poorly defined and confusing overloads, such as <code>Normalize</code>/<code>NormalizeExact</code>/<code>NormalizeApprox</code>, have been audited and condensed.&nbsp;Where appropriate estimate instructions exist and show meaningful performance advantages, we have added an <code>Estimate</code> overload that exposes the reduced precision instruction, but by default all operations not marked Estimate are now full precision. We’ve optimized to an extent that there are still performance improvements with the new code, despite the increased accuracy.</p> 
       <h2>Transform decomposition</h2> 
       <p>Due to historical reasons, the <code>Transform</code> class in Lumberyard stores its internal state in a 3×4 matrix rather than in distinct translation, orientation, and scale fields. As most gameplay systems expect separate translation and orientation values, we incurred a large cost decomposing the matrix representation into distinct values, and then converting back to matrix form again upon fetching results. Such gameplay systems included physics, AI, networking, and audio. In addition, the matrix representation allowed invalid transform states to be stored, such as matrices with skew or singular matrices. Because of this, we have removed matrix oriented accessors from the <code>AZ::Transform</code> API and moved its internal storage to distinct translation, orientation, and scale values. This allows optimal interaction with gameplay code, physics, AI, pathfinding, networking, and other subsystems that expect distinct values, and we support an efficient conversion to <code>Matrix3x4</code> for use-cases like rendering where the matrix form is preferable to the decomposed form.</p> 
       <h2>SIMD rewrite</h2> 
       <p>Our rewrite includes types and operations for <code>Vec1</code>, <code>Vec2</code>, <code>Vec3</code>, and <code>Vec4</code> float and integral types. This SIMD layer has scalar fallback, SSE 4.1, and ARM Neon backends, and makes it easy for future support of AVX-512 and other enhanced register-width SIMD extensions. Anyone familiar with the SIMD intrinsics used for the VMX execution units on PowerPC architectures should find the new <code>AZ::Simd</code> layer somewhat familiar.</p> 
       <p>The new SIMD trig methods are significantly more accurate than the previous SIMD <code>sine</code> and <code>cosine</code> methods, and are faster by a considerable margin as well.</p> 
       <p>The <code>VectorFloat</code> SIMD wrapper from Lumberyard 1.x has also been removed, as benchmarking using modern compilers confirmed that it provided no benefit and actually harmed performance in many situations, and only served to make calling code more complex.</p> 
       <h2>Testing and benchmarking</h2> 
       <p>We now have slightly more than 1,000 math unit tests that have very close to 100% coverage across the entirety of the math library. These test the performance of the various math classes and APIs, which we’ve been using to validate the performance impact of all of our changes.</p> 
       <h2>Accuracy</h2> 
       <p>Both the new and old SIMD transcendental functions have been tested for numerical accuracy. We will go into greater detail on this in a future post.</p> 
       <p><img class="aligncenter size-full wp-image-3282" src="/blogs/building-a-smarter-foundation-math-improvements-in-lumberyard/images/Math_Lumberyard_Dev_Blog_Image1.png" alt="" width="776" height="530"></p> 
       <h2>Performance</h2> 
       <p>We’ve written over 450 new microbenchmarks to monitor the performance of the vast majority of the Lumberyard math API. We used these benchmarks to validate that work done on the new math library resulted in performance improvements over the old math library.</p> 
       <p><img loading="lazy" class="aligncenter size-large wp-image-3283" src="/blogs/building-a-smarter-foundation-math-improvements-in-lumberyard/images/Math_Lumberyard_Dev_Blog_Image2-1024x628.png" alt="" width="1024" height="628"></p> 
       <p><img loading="lazy" class="aligncenter size-large wp-image-3284" src="/blogs/building-a-smarter-foundation-math-improvements-in-lumberyard/images/Math_Lumberyard_Dev_Blog_Image3-1024x607.png" alt="" width="1024" height="607"></p> 
       <p>Overall, we’ve made a number of improvements to the mathematical foundations of Lumberyard in the last year; changes that we are excited to roll out to you in a future release. The end result will be faster frame rates, better platform support especially on ARM devices, higher accuracy, and more compute resources available for animation, special effects, and gameplay. Additionally, this new math library enables us to deliver some exciting new features, as well as backfill some longstanding gaps in the engines functionality.</p> 
       <p>Let us know your thoughts in the comments, and look for a follow-up on this topic soon!</p> 
       <p>&nbsp;</p> 
       